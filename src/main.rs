use std::{
    collections::{BTreeMap, HashSet},
    fmt::{Display, Formatter},
};

use itertools::Itertools;
use rust_decimal::Decimal;
use rust_decimal_macros::dec;

fn main() -> Result<(), inquire::InquireError> {
    let total = get_amount("Total:")?;
    let gst = get_amount("GST:")?;
    let pst = get_amount("PST:")?;

    let pre_tax = total - gst - pst;
    let pst_item_total = pst / dec!(0.07);
    let gst_item_total = gst / dec!(0.05);

    let mut cur_total = dec!(0);
    let mut cur_pst_total = dec!(0);
    let mut cur_gst_total = dec!(0);

    println!();

    let mut last_item_taxes = HashSet::new();
    let mut categories = HashSet::<String>::new();
    let mut records = vec![];

    loop {
        println!("======");
        println!("Remaining amount: {}", pre_tax - cur_total);
        println!(
            "Remaining amount to match PST: {}",
            pst_item_total - cur_pst_total
        );
        println!(
            "Remaining amount to match GST: {}",
            gst_item_total - cur_gst_total
        );
        println!();

        if cur_total >= pre_tax {
            break;
        }

        let name = inquire::Text::new("Item:").prompt()?;

        let category = get_category(&categories)?;
        categories.insert(category.clone());

        let applicable_taxes = get_applicable_taxes(last_item_taxes)?;
        last_item_taxes = applicable_taxes.clone();

        let base_cost = inquire::CustomType::<Decimal>::new("Price:").prompt()?;

        cur_total += base_cost;

        let mut cost = base_cost;
        if applicable_taxes.contains(&Tax::GST) {
            cur_gst_total += base_cost;
            cost += base_cost * dec!(0.05);
        }
        if applicable_taxes.contains(&Tax::PST) {
            cur_pst_total += base_cost;
            cost += base_cost * dec!(0.07);
        }

        let record = Record {
            item: name,
            category,
            total: cost,
        };

        records.push(record);
    }

    for r in records.iter() {
        println!("{:?}", r);
    }

    let grouped_items =
        records
            .into_iter()
            .fold(BTreeMap::<String, Vec<Record>>::new(), |mut acc, r| {
                acc.entry(r.category.clone()).or_default().push(r);
                acc
            });

    let grouped_items = grouped_items.into_iter().map(|g| {
        let cat = g.0;
        let items = g.1;

        CategoryGroup {
            items: some_kind_of_uppercase_first_letter(
                items.iter().map(|r| r.item.clone()).join(", "),
            ),
            category: cat,
            total: items.iter().fold(Decimal::ZERO, |t, r| t + r.total),
        }
    });

    for g in grouped_items {
        println!("{:05} - {}", g.total, g.category);
        println!("{}", g.items);
        println!();
    }
    Ok(())
}

fn get_category(categories: &HashSet<String>) -> Result<String, inquire::InquireError> {
    let mut categories = categories.iter().cloned().collect::<Vec<String>>();
    categories.sort();

    inquire::Text::new("Category:")
        .with_suggester(&|input| {
            Ok(categories
                .iter()
                .cloned()
                .filter(|c| c.contains(input))
                .collect())
        })
        .prompt()
}

fn get_applicable_taxes(
    last_item_taxes: HashSet<Tax>,
) -> Result<HashSet<Tax>, inquire::InquireError> {
    let options = Tax::VARIANTS.to_vec();

    let selection_default = options
        .iter()
        .enumerate()
        .filter(|(_, t)| last_item_taxes.contains(t))
        .map(|(i, _)| i)
        .collect::<Vec<usize>>();

    let taxes = inquire::MultiSelect::new("Taxes:", options)
        .with_default(&selection_default)
        .prompt()?;

    Ok(HashSet::from_iter(taxes.into_iter()))
}

fn get_amount(msg: &str) -> Result<Decimal, inquire::InquireError> {
    inquire::CustomType::new(msg).prompt()
}

#[derive(Default, Debug, Clone)]
struct CategoryGroup {
    items: String,
    category: String,
    total: Decimal,
}

#[derive(Debug, Clone)]
struct Record {
    item: String,
    category: String,
    total: Decimal,
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
enum Tax {
    GST,
    PST,
}

impl Tax {
    // could be generated by macro
    const VARIANTS: &'static [Tax] = &[Self::GST, Self::PST];
}

impl Display for Tax {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(f, "{:?}", self)
    }
}

fn some_kind_of_uppercase_first_letter(s: String) -> String {
    let mut c = s.chars();
    match c.next() {
        None => String::new(),
        Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
    }
}
